# More Effective C++ 读书笔记

## 基础议题

### 条款1：指针与引用的区别

**区别：**

1. 引用不可指向空置，指针可【故指针需在使用前测试合法性】
2. 指针可被重新赋值，引用不可

**使用依据：**

1. 是否存在不指向任何对象的可能？
2. 是否存在指向不同对象的可能？



### 条款2：尽量使用C++风格的类型转换

**原因：**

1. C风格的类型转换过于自由
2. C风格的类型转换难以识别



### 条款3：不要对数组使用多态

**原因：**

1. 数组元素间的地址相隔与其类型相同，多态会导致地址出错



### 条款4：避免无用的缺省构造函数

**原因：**

1. 构造函数蕴含进行了有意义初始化的保证，否则将引入一系列对数据有效性检测的代码



### 条款5：谨慎定义类型转换函数

**原因：**

1. 编译器会在一切可能进行隐式类型转换的地方进行转换

**对策：**

	1. 使用 explicit 关键字
 	2. 不定义类型转换函数，转而定义成员函数



### 条款6：自增、自减操作符前缀形式与后缀形式的区别

```c++
class Exp{
public:
	Exp& operator++();//前缀++
    const Exp operator++(int);//后缀[const预防连续两次后缀++]
    //C++规定后缀形式有一个int类型参数，当函数被调用时编译器传递一个0作为int参数的值给该函数
}
```



### 条款7：不要重载"&&","||",或","

**原因：**

1. 函数调用与短路求值相冲突
2. 逗号操作符的运算顺序无法被模仿

**原则：**

- 重载操作符以提升可读性而非迷惑读者



### 条款8：理解各种不同含义的new和delete

- new操作符（new operator）：先分配内存（operator new），再调用构造函数初始化对象

```C++
void* operator new(size_t size); // 函数operator new的通常声明
//一般不直接调用operator new
```

- placement new（特殊的operator new）：在已分配的内存上初始化对象

```c++
char *buffer = new char[100];
Cls *p = new (buffer) Cls();
```

